// Code generated by protoc-gen-go. DO NOT EDIT.
// source: envoy/service/ratelimit/v3alpha/rls.proto

package envoy_service_ratelimit_v3alpha

import (
	context "context"
	fmt "fmt"
	_ "github.com/cncf/udpa/go/udpa/annotations"
	core "github.com/envoyproxy/go-control-plane/envoy/api/v3alpha/core"
	ratelimit "github.com/envoyproxy/go-control-plane/envoy/api/v3alpha/ratelimit"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RateLimitResponse_Code int32

const (
	RateLimitResponse_UNKNOWN    RateLimitResponse_Code = 0
	RateLimitResponse_OK         RateLimitResponse_Code = 1
	RateLimitResponse_OVER_LIMIT RateLimitResponse_Code = 2
)

var RateLimitResponse_Code_name = map[int32]string{
	0: "UNKNOWN",
	1: "OK",
	2: "OVER_LIMIT",
}

var RateLimitResponse_Code_value = map[string]int32{
	"UNKNOWN":    0,
	"OK":         1,
	"OVER_LIMIT": 2,
}

func (x RateLimitResponse_Code) String() string {
	return proto.EnumName(RateLimitResponse_Code_name, int32(x))
}

func (RateLimitResponse_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{1, 0}
}

type RateLimitResponse_RateLimit_Unit int32

const (
	RateLimitResponse_RateLimit_UNKNOWN RateLimitResponse_RateLimit_Unit = 0
	RateLimitResponse_RateLimit_SECOND  RateLimitResponse_RateLimit_Unit = 1
	RateLimitResponse_RateLimit_MINUTE  RateLimitResponse_RateLimit_Unit = 2
	RateLimitResponse_RateLimit_HOUR    RateLimitResponse_RateLimit_Unit = 3
	RateLimitResponse_RateLimit_DAY     RateLimitResponse_RateLimit_Unit = 4
)

var RateLimitResponse_RateLimit_Unit_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECOND",
	2: "MINUTE",
	3: "HOUR",
	4: "DAY",
}

var RateLimitResponse_RateLimit_Unit_value = map[string]int32{
	"UNKNOWN": 0,
	"SECOND":  1,
	"MINUTE":  2,
	"HOUR":    3,
	"DAY":     4,
}

func (x RateLimitResponse_RateLimit_Unit) String() string {
	return proto.EnumName(RateLimitResponse_RateLimit_Unit_name, int32(x))
}

func (RateLimitResponse_RateLimit_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{1, 0, 0}
}

type RateLimitRequest struct {
	Domain               string                           `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	Descriptors          []*ratelimit.RateLimitDescriptor `protobuf:"bytes,2,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	HitsAddend           uint32                           `protobuf:"varint,3,opt,name=hits_addend,json=hitsAddend,proto3" json:"hits_addend,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *RateLimitRequest) Reset()         { *m = RateLimitRequest{} }
func (m *RateLimitRequest) String() string { return proto.CompactTextString(m) }
func (*RateLimitRequest) ProtoMessage()    {}
func (*RateLimitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{0}
}

func (m *RateLimitRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitRequest.Unmarshal(m, b)
}
func (m *RateLimitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitRequest.Marshal(b, m, deterministic)
}
func (m *RateLimitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitRequest.Merge(m, src)
}
func (m *RateLimitRequest) XXX_Size() int {
	return xxx_messageInfo_RateLimitRequest.Size(m)
}
func (m *RateLimitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitRequest proto.InternalMessageInfo

func (m *RateLimitRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *RateLimitRequest) GetDescriptors() []*ratelimit.RateLimitDescriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

func (m *RateLimitRequest) GetHitsAddend() uint32 {
	if m != nil {
		return m.HitsAddend
	}
	return 0
}

type RateLimitResponse struct {
	OverallCode          RateLimitResponse_Code                `protobuf:"varint,1,opt,name=overall_code,json=overallCode,proto3,enum=envoy.service.ratelimit.v3alpha.RateLimitResponse_Code" json:"overall_code,omitempty"`
	Statuses             []*RateLimitResponse_DescriptorStatus `protobuf:"bytes,2,rep,name=statuses,proto3" json:"statuses,omitempty"`
	Headers              []*core.HeaderValue                   `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty"`
	RequestHeadersToAdd  []*core.HeaderValue                   `protobuf:"bytes,4,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *RateLimitResponse) Reset()         { *m = RateLimitResponse{} }
func (m *RateLimitResponse) String() string { return proto.CompactTextString(m) }
func (*RateLimitResponse) ProtoMessage()    {}
func (*RateLimitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{1}
}

func (m *RateLimitResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitResponse.Unmarshal(m, b)
}
func (m *RateLimitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitResponse.Marshal(b, m, deterministic)
}
func (m *RateLimitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitResponse.Merge(m, src)
}
func (m *RateLimitResponse) XXX_Size() int {
	return xxx_messageInfo_RateLimitResponse.Size(m)
}
func (m *RateLimitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitResponse proto.InternalMessageInfo

func (m *RateLimitResponse) GetOverallCode() RateLimitResponse_Code {
	if m != nil {
		return m.OverallCode
	}
	return RateLimitResponse_UNKNOWN
}

func (m *RateLimitResponse) GetStatuses() []*RateLimitResponse_DescriptorStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *RateLimitResponse) GetHeaders() []*core.HeaderValue {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RateLimitResponse) GetRequestHeadersToAdd() []*core.HeaderValue {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

type RateLimitResponse_RateLimit struct {
	RequestsPerUnit      uint32                           `protobuf:"varint,1,opt,name=requests_per_unit,json=requestsPerUnit,proto3" json:"requests_per_unit,omitempty"`
	Unit                 RateLimitResponse_RateLimit_Unit `protobuf:"varint,2,opt,name=unit,proto3,enum=envoy.service.ratelimit.v3alpha.RateLimitResponse_RateLimit_Unit" json:"unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *RateLimitResponse_RateLimit) Reset()         { *m = RateLimitResponse_RateLimit{} }
func (m *RateLimitResponse_RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimitResponse_RateLimit) ProtoMessage()    {}
func (*RateLimitResponse_RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{1, 0}
}

func (m *RateLimitResponse_RateLimit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitResponse_RateLimit.Unmarshal(m, b)
}
func (m *RateLimitResponse_RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitResponse_RateLimit.Marshal(b, m, deterministic)
}
func (m *RateLimitResponse_RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitResponse_RateLimit.Merge(m, src)
}
func (m *RateLimitResponse_RateLimit) XXX_Size() int {
	return xxx_messageInfo_RateLimitResponse_RateLimit.Size(m)
}
func (m *RateLimitResponse_RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitResponse_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitResponse_RateLimit proto.InternalMessageInfo

func (m *RateLimitResponse_RateLimit) GetRequestsPerUnit() uint32 {
	if m != nil {
		return m.RequestsPerUnit
	}
	return 0
}

func (m *RateLimitResponse_RateLimit) GetUnit() RateLimitResponse_RateLimit_Unit {
	if m != nil {
		return m.Unit
	}
	return RateLimitResponse_RateLimit_UNKNOWN
}

type RateLimitResponse_DescriptorStatus struct {
	Code                 RateLimitResponse_Code       `protobuf:"varint,1,opt,name=code,proto3,enum=envoy.service.ratelimit.v3alpha.RateLimitResponse_Code" json:"code,omitempty"`
	CurrentLimit         *RateLimitResponse_RateLimit `protobuf:"bytes,2,opt,name=current_limit,json=currentLimit,proto3" json:"current_limit,omitempty"`
	LimitRemaining       uint32                       `protobuf:"varint,3,opt,name=limit_remaining,json=limitRemaining,proto3" json:"limit_remaining,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *RateLimitResponse_DescriptorStatus) Reset()         { *m = RateLimitResponse_DescriptorStatus{} }
func (m *RateLimitResponse_DescriptorStatus) String() string { return proto.CompactTextString(m) }
func (*RateLimitResponse_DescriptorStatus) ProtoMessage()    {}
func (*RateLimitResponse_DescriptorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5929a49ed6c3ed07, []int{1, 1}
}

func (m *RateLimitResponse_DescriptorStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RateLimitResponse_DescriptorStatus.Unmarshal(m, b)
}
func (m *RateLimitResponse_DescriptorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RateLimitResponse_DescriptorStatus.Marshal(b, m, deterministic)
}
func (m *RateLimitResponse_DescriptorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitResponse_DescriptorStatus.Merge(m, src)
}
func (m *RateLimitResponse_DescriptorStatus) XXX_Size() int {
	return xxx_messageInfo_RateLimitResponse_DescriptorStatus.Size(m)
}
func (m *RateLimitResponse_DescriptorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitResponse_DescriptorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitResponse_DescriptorStatus proto.InternalMessageInfo

func (m *RateLimitResponse_DescriptorStatus) GetCode() RateLimitResponse_Code {
	if m != nil {
		return m.Code
	}
	return RateLimitResponse_UNKNOWN
}

func (m *RateLimitResponse_DescriptorStatus) GetCurrentLimit() *RateLimitResponse_RateLimit {
	if m != nil {
		return m.CurrentLimit
	}
	return nil
}

func (m *RateLimitResponse_DescriptorStatus) GetLimitRemaining() uint32 {
	if m != nil {
		return m.LimitRemaining
	}
	return 0
}

func init() {
	proto.RegisterEnum("envoy.service.ratelimit.v3alpha.RateLimitResponse_Code", RateLimitResponse_Code_name, RateLimitResponse_Code_value)
	proto.RegisterEnum("envoy.service.ratelimit.v3alpha.RateLimitResponse_RateLimit_Unit", RateLimitResponse_RateLimit_Unit_name, RateLimitResponse_RateLimit_Unit_value)
	proto.RegisterType((*RateLimitRequest)(nil), "envoy.service.ratelimit.v3alpha.RateLimitRequest")
	proto.RegisterType((*RateLimitResponse)(nil), "envoy.service.ratelimit.v3alpha.RateLimitResponse")
	proto.RegisterType((*RateLimitResponse_RateLimit)(nil), "envoy.service.ratelimit.v3alpha.RateLimitResponse.RateLimit")
	proto.RegisterType((*RateLimitResponse_DescriptorStatus)(nil), "envoy.service.ratelimit.v3alpha.RateLimitResponse.DescriptorStatus")
}

func init() {
	proto.RegisterFile("envoy/service/ratelimit/v3alpha/rls.proto", fileDescriptor_5929a49ed6c3ed07)
}

var fileDescriptor_5929a49ed6c3ed07 = []byte{
	// 687 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xc7, 0x71, 0x12, 0x85, 0x70, 0xc2, 0x87, 0x99, 0x2b, 0x71, 0xa3, 0x2c, 0x2e, 0x90, 0xbb,
	0xb8, 0xdc, 0x52, 0xec, 0x36, 0x48, 0x6d, 0x15, 0x15, 0xaa, 0x40, 0x90, 0x40, 0x40, 0x82, 0x26,
	0x84, 0x7e, 0x6c, 0xac, 0x21, 0x1e, 0x91, 0x91, 0x8c, 0xc7, 0x9d, 0x19, 0x47, 0xa5, 0x4f, 0xc0,
	0xa6, 0xed, 0xbe, 0x6f, 0xd1, 0x87, 0xe8, 0x13, 0xf4, 0x85, 0x2a, 0x8f, 0x1d, 0x27, 0x0d, 0xad,
	0x20, 0xb4, 0x3b, 0xcf, 0x99, 0xff, 0xf9, 0x8d, 0xcf, 0xff, 0x9c, 0x19, 0xf8, 0x9f, 0xfa, 0x7d,
	0x7e, 0x65, 0x4b, 0x2a, 0xfa, 0xac, 0x4b, 0x6d, 0x41, 0x14, 0xf5, 0xd8, 0x25, 0x53, 0x76, 0x7f,
	0x93, 0x78, 0x41, 0x8f, 0xd8, 0xc2, 0x93, 0x56, 0x20, 0xb8, 0xe2, 0x68, 0x59, 0x4b, 0xad, 0x44,
	0x6a, 0xa5, 0x52, 0x2b, 0x91, 0x96, 0x57, 0x63, 0x16, 0x09, 0x58, 0x9a, 0xdd, 0xe5, 0x82, 0xda,
	0xe7, 0x44, 0xd2, 0x98, 0x51, 0x5e, 0xbf, 0x29, 0x19, 0x1e, 0x39, 0x24, 0xc6, 0xe2, 0xd5, 0xd0,
	0x0d, 0x88, 0x4d, 0x7c, 0x9f, 0x2b, 0xa2, 0x18, 0xf7, 0xa5, 0xdd, 0xa7, 0x42, 0x32, 0xee, 0x33,
	0xff, 0x22, 0x91, 0xfc, 0xdd, 0x27, 0x1e, 0x73, 0x89, 0xa2, 0xf6, 0xe0, 0x23, 0xde, 0xa8, 0x7c,
	0x33, 0xc0, 0xc4, 0x44, 0xd1, 0xa3, 0x88, 0x87, 0xe9, 0xdb, 0x90, 0x4a, 0x85, 0x96, 0x20, 0xef,
	0xf2, 0x4b, 0xc2, 0xfc, 0x92, 0xb1, 0x62, 0xac, 0xcd, 0xe0, 0x64, 0x85, 0x30, 0x14, 0x5d, 0x2a,
	0xbb, 0x82, 0x05, 0x8a, 0x0b, 0x59, 0xca, 0xac, 0x64, 0xd7, 0x8a, 0xd5, 0x47, 0x56, 0x5c, 0x2f,
	0x09, 0xd8, 0xa0, 0xc2, 0x91, 0x9a, 0x53, 0x76, 0x23, 0x4d, 0xc4, 0xa3, 0x10, 0xb4, 0x0c, 0xc5,
	0x1e, 0x53, 0xd2, 0x21, 0xae, 0x4b, 0x7d, 0xb7, 0x94, 0x5d, 0x31, 0xd6, 0xe6, 0x30, 0x44, 0xa1,
	0xba, 0x8e, 0xd4, 0xaa, 0x9f, 0xbf, 0x5e, 0xff, 0xb3, 0x01, 0xeb, 0xbf, 0x74, 0xb5, 0x6a, 0x8d,
	0x17, 0x50, 0xf9, 0x54, 0x80, 0xc5, 0x91, 0xa0, 0x0c, 0xb8, 0x2f, 0x29, 0x7a, 0x03, 0xb3, 0xbc,
	0x4f, 0x05, 0xf1, 0x3c, 0xa7, 0xcb, 0x5d, 0xaa, 0x8b, 0x9b, 0xaf, 0x3e, 0xb5, 0x6e, 0xe9, 0x97,
	0x75, 0x83, 0x64, 0xed, 0x72, 0x97, 0xe2, 0x62, 0x02, 0x8b, 0x16, 0xc8, 0x81, 0x82, 0x54, 0x44,
	0x85, 0x92, 0x0e, 0x7c, 0xd9, 0xbd, 0x07, 0x77, 0x68, 0x52, 0x5b, 0xc3, 0x70, 0x0a, 0x45, 0x5b,
	0x30, 0xdd, 0xa3, 0xc4, 0xa5, 0x42, 0x96, 0xb2, 0x9a, 0xff, 0xef, 0x4f, 0x7c, 0x8f, 0xc6, 0xc8,
	0xda, 0xd7, 0xb2, 0x33, 0xe2, 0x85, 0x14, 0x0f, 0x72, 0xd0, 0x2b, 0x58, 0x12, 0xb1, 0x39, 0x4e,
	0x12, 0x72, 0x14, 0x8f, 0x4c, 0x2f, 0xe5, 0xee, 0x4e, 0xfb, 0x2b, 0x41, 0xc4, 0x31, 0x79, 0xca,
	0xeb, 0xae, 0x5b, 0xfe, 0x90, 0x81, 0x99, 0xb4, 0x12, 0xf4, 0x00, 0x16, 0x13, 0x91, 0x74, 0x02,
	0x2a, 0x9c, 0xd0, 0x67, 0x4a, 0x1b, 0x3d, 0x87, 0x17, 0x06, 0x1b, 0x27, 0x54, 0x74, 0x7c, 0xa6,
	0x50, 0x07, 0x72, 0x7a, 0x3b, 0xa3, 0xfb, 0x50, 0xbf, 0x87, 0x5f, 0x69, 0xc4, 0x8a, 0x80, 0x58,
	0xe3, 0x2a, 0xdb, 0x90, 0xd3, 0xf8, 0x22, 0x4c, 0x77, 0x9a, 0x87, 0xcd, 0xd6, 0xcb, 0xa6, 0x39,
	0x85, 0x00, 0xf2, 0xed, 0xbd, 0xdd, 0x56, 0xb3, 0x61, 0x1a, 0xd1, 0xf7, 0xf1, 0x41, 0xb3, 0x73,
	0xba, 0x67, 0x66, 0x50, 0x01, 0x72, 0xfb, 0xad, 0x0e, 0x36, 0xb3, 0x68, 0x1a, 0xb2, 0x8d, 0xfa,
	0x6b, 0x33, 0x57, 0xdb, 0x8a, 0x06, 0xee, 0x19, 0x3c, 0xb9, 0xdb, 0xc0, 0x8d, 0xff, 0x49, 0xf9,
	0x4b, 0x06, 0xcc, 0xf1, 0x3e, 0xa2, 0x43, 0xc8, 0xfd, 0x89, 0x91, 0xd3, 0x10, 0x44, 0x60, 0xae,
	0x1b, 0x0a, 0x41, 0x7d, 0xe5, 0xe8, 0x2c, 0x6d, 0x60, 0xb1, 0xfa, 0xfc, 0x77, 0x0c, 0xc4, 0xb3,
	0x09, 0x32, 0x6e, 0xe3, 0x7f, 0xb0, 0xa0, 0x53, 0x1d, 0x41, 0xa3, 0x9b, 0xcf, 0xfc, 0x8b, 0xe4,
	0x66, 0xce, 0x7b, 0x71, 0x7e, 0x12, 0xad, 0x35, 0x22, 0xb3, 0x5e, 0xc0, 0xd6, 0x44, 0x66, 0x8d,
	0xdb, 0x53, 0x59, 0x87, 0x9c, 0xbe, 0x45, 0x3f, 0xb4, 0x2c, 0x0f, 0x99, 0xd6, 0xa1, 0x69, 0xa0,
	0x79, 0x80, 0xd6, 0xd9, 0x1e, 0x76, 0x8e, 0x0e, 0x8e, 0x0f, 0x4e, 0xcd, 0x4c, 0x6d, 0x33, 0x3a,
	0xd2, 0x82, 0x87, 0x93, 0x1c, 0x59, 0xfd, 0x38, 0xfa, 0xce, 0xb5, 0xe3, 0x1c, 0xf4, 0x1e, 0x16,
	0xda, 0x3d, 0x1e, 0x7a, 0xee, 0x70, 0x7e, 0x1f, 0x4f, 0x62, 0xa2, 0x1e, 0xe7, 0x72, 0x75, 0x72,
	0xdf, 0x2b, 0x53, 0x3b, 0xdb, 0xb0, 0xc1, 0x78, 0x9c, 0x19, 0x08, 0xfe, 0xee, 0xea, 0x36, 0xc8,
	0x4e, 0x01, 0x7b, 0xf2, 0x24, 0x7a, 0xb3, 0x4f, 0x8c, 0x6b, 0xc3, 0x38, 0xcf, 0xeb, 0xf7, 0x7b,
	0xf3, 0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xda, 0x79, 0x8f, 0x3e, 0x99, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RateLimitServiceClient is the client API for RateLimitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RateLimitServiceClient interface {
	ShouldRateLimit(ctx context.Context, in *RateLimitRequest, opts ...grpc.CallOption) (*RateLimitResponse, error)
}

type rateLimitServiceClient struct {
	cc *grpc.ClientConn
}

func NewRateLimitServiceClient(cc *grpc.ClientConn) RateLimitServiceClient {
	return &rateLimitServiceClient{cc}
}

func (c *rateLimitServiceClient) ShouldRateLimit(ctx context.Context, in *RateLimitRequest, opts ...grpc.CallOption) (*RateLimitResponse, error) {
	out := new(RateLimitResponse)
	err := c.cc.Invoke(ctx, "/envoy.service.ratelimit.v3alpha.RateLimitService/ShouldRateLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RateLimitServiceServer is the server API for RateLimitService service.
type RateLimitServiceServer interface {
	ShouldRateLimit(context.Context, *RateLimitRequest) (*RateLimitResponse, error)
}

// UnimplementedRateLimitServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRateLimitServiceServer struct {
}

func (*UnimplementedRateLimitServiceServer) ShouldRateLimit(ctx context.Context, req *RateLimitRequest) (*RateLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShouldRateLimit not implemented")
}

func RegisterRateLimitServiceServer(s *grpc.Server, srv RateLimitServiceServer) {
	s.RegisterService(&_RateLimitService_serviceDesc, srv)
}

func _RateLimitService_ShouldRateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ShouldRateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/envoy.service.ratelimit.v3alpha.RateLimitService/ShouldRateLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ShouldRateLimit(ctx, req.(*RateLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RateLimitService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.service.ratelimit.v3alpha.RateLimitService",
	HandlerType: (*RateLimitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShouldRateLimit",
			Handler:    _RateLimitService_ShouldRateLimit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "envoy/service/ratelimit/v3alpha/rls.proto",
}
